name: "Test, Build, Dockerise and Update-configmap"
on:
  workflow_call:
    inputs:
      TESTCOVERAGE_THRESHOLD:
        description: 'required input'
        required: true
        type: string
      POSTMAN_ENABLED:
        required: true
        type: boolean
      APP_NAME:
        description: 'name of postman collection file'
        required: true
        type: string
      GO_VERSION:
        description: 'go version'
        required: false
        type: string
        default: '1.20'
      ADD_SCHEMA:
        description: 'enable step to load DB schema'
        required: false
        type: boolean
        default: false
      SCHEMA_COMMAND:
        description: 'command to load DB schema'
        required: false
        type: string
      EXTRA_DEPENDENCIES:
        description: 'enable step to install extra dependencies'
        required: false
        type: boolean
        default: false
      DEPENDENCIES_COMMAND:
        description: 'commands to install extra dependencies'
        required: false
        type: string
      MYSQL_ENABLE:
        required: false
        type: boolean
        default: false
      POSTGRES_ENABLE:
        required: false
        type: boolean
        default: false
      REDIS_ENABLE:
        required: false
        type: boolean
        default: false
      ZIPKIN_ENABLE:
        required: false
        type: boolean
        default: false
      ELASTIC_SEARCH_ENABLE:
        required: false
        type: boolean
        default: false
      KAFKA_ENABLE:
        required: false
        type: boolean
        default: false
      MONGO_ENABLE:
        required: false
        type: boolean
        default: false
      MSSQL_ENABLE:
        required: false
        type: boolean
        default: false
      DYNAMODB_ENABLE:
        required: false
        type: boolean
        default: false
      CASSANDRA_ENABLE:
        required: false
        type: boolean
        default: false
      IMAGE_REGISTRY:
        type: string
        required: true
      GAR_PROJECT:
        type: string
        required: true
      GAR_REGISTRY:
        type: string
        required: true
      CLUSTER_PROJECT:
        type: string
        required: true
      CLUSTER_NAME:
        type: string
        required: true
      NAMESPACE:
        type: string
        required: true
      DOCKER_FILE_PATH:
        description: 'path of docker file'
        required: true
        type: string
      BUILD_COMMAND:
        description: 'go build command'
        required: true
        type: string
      ARTIFACT_PATH:
        description: "path used for build with respect to main.go file"
        required: true
        type: string
      SHA:
        type: string
        required: true
      BUILD_ARGUMENTS:
        description: 'build arguments for DockerFile'
        required: false
        type: string
      ENV_FILE_PATH:
        description: 'env file path'
        required: false
        type: string
        default: "./configs/.stage.env"

    secrets:
      PAT:
        description: 'required input'
        required: true
      GAR_KEY:
        description: 'required input'
        required: true

    outputs:
      SHA:
        description: "commit sha for image"
        value: ${{ jobs.test.outputs.sha }}


jobs:
  test:
    runs-on: ubuntu-latest
    name: ðŸ§ª Test and linters
    if: (github.ref == 'refs/heads/development') || (github.ref == 'refs/heads/main')  || (github.ref == 'refs/heads/master') || github.event_name == 'pull_request' || github.event_name == 'push'
    outputs:
      sha: ${{ steps.output-sha.outputs.sha }}
    services:
      mysql:
        image: ${{ inputs.MYSQL_ENABLE && 'mysql:8.0.30' || '' }}
        ports:
          - "3306:3306"
        env:
          MYSQL_DATABASE: "test"
          MYSQL_ROOT_PASSWORD: "password"
          options: --health-cmd="mysqladmin ping" --health-interval=10s --health-timeout=5s --health-retries=5

      postgres:
        image: ${{ inputs.POSTGRES_ENABLE && 'postgres:15.1' || '' }}
        ports:
          - 5432:5432
        env:
          POSTGRES_PASSWORD: password
          POSTGRES_USER: postgres
          POSTGRES_DB: test

      redis:
        image: ${{ inputs.REDIS_ENABLE && 'redis:5.0.14' || '' }}
        ports:
          - "6379:6379"
        options: "--entrypoint redis-server"

      zipkin:
        image: ${{ inputs.ZIPKIN_ENABLE && 'openzipkin/zipkin' || '' }}
        ports:
          - "9411:9411"

      elasticsearch:
        image: ${{ inputs.ELASTIC_SEARCH_ENABLE && 'elasticsearch:6.8.6' || '' }}
        ports:
          - 2012:9200
          - 2013:9300
          - 9200:9200
        env:
          discovery type: "single-node"

      kafka:
        image: ${{ inputs.KAFKA_ENABLE && 'krisgeus/docker-kafka' || '' }}
        ports:
          - 2008:2008
          - 2009:2009
        env:
          ADVERTISED_LISTENERS: 'PLAINTEXT://localhost:2008,INTERNAL://localhost:2009'
          LISTENERS: 'PLAINTEXT://0.0.0.0:2008,INTERNAL://0.0.0.0:2009'
          SECURITY_PROTOCOL_MAP: 'PLAINTEXT:PLAINTEXT,INTERNAL:PLAINTEXT'
          INTER_BROKER: 'INTERNAL'
          KAFKA_CREATE_TOPICS: 'test-topic'
          KAFKA_HOSTS: 'localhost:2008,localhost:2009'
          KAFKA_TOPIC: 'test-topic'

      mongo:
        image: ${{ inputs.MONGO_ENABLE && 'mongo:6.0.2' || '' }}
        ports:
          - "27017:27017"
        env:
          MONGO_INITDB_ROOT_USERNAME: admin
          MONGO_INITDB_ROOT_PASSWORD: admin123

      mssql:
        image: ${{ inputs.MSSQL_ENABLE && 'mcr.microsoft.com/mssql/server:2022-latest' || '' }}
        ports:
          - "1433:1433"
        env:
          ACCEPT_EULA: Y
          SA_PASSWORD: reallyStrongPwd123

      dynamodb:
        image: ${{ inputs.DYNAMODB_ENABLE && 'amazon/dynamodb-local' || '' }}
        ports:
          - "2021:8000"

      cassandra:
        image: ${{ inputs.CASSANDRA_ENABLE && 'cassandra:4.0.6' || '' }}
        ports:
          - 9041:9042
        options: --health-cmd "cqlsh --debug"

    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-go@v4
        with:
          go-version: '${{ inputs.GO_VERSION }}'

      - name: Add DB Schema
        if: ${{ inputs.ADD_SCHEMA }}
        run: |
          ${{ inputs.SCHEMA_COMMAND }}

      - name: Get dependencies
        run: |
          git config --global url."https://${{ secrets.PAT }}:x-oauth-basic@github.com/".insteadOf "https://github.com/"
          git config --global http.sslVerify false
          go mod download

      - name: Extra dependencies
        if: ${{ inputs.EXTRA_DEPENDENCIES }}
        run: |
          ${{ inputs.DEPENDENCIES_COMMAND }}

      - name: golangci-lint
        uses: golangci/golangci-lint-action@v3
        with:
          version: v1.54.2
          args: --timeout 8m
          skip-pkg-cache: true
          skip-build-cache: true


      - name: Test
        run: |
          mkdir -p temp/build
          GOFR_ENV=test go test ./... -count=1 -v -coverprofile temp/cover.out -coverpkg=./...
          cat temp/cover.out | grep -v "mock_interface" | grep -v "migrations" > temp/coverage.out

      - name: Test Coverage report
        run: |
          go tool cover -func=temp/coverage.out | tee temp/c.out

      - name: Generate and Commit Coverage Badge
        if: (github.event_name == 'push') && (github.ref == 'refs/heads/main' || github.ref == 'refs/heads/master')
        run: |
          go install github.com/AlexBeauchemin/gobadge@latest
          gobadge -filename=temp/c.out -target=$(pwd)/README.md
          git config --global user.email "action@github.com" && git config --global user.name "GitHub-Action"
          git config --global --add safe.directory /__w/$(basename ${{ github.repository }})/$(basename ${{ github.repository }})
          git diff --quiet --exit-code README.md || git commit README.md -m "updating coverage in README.md"

      - name: Push Coverage Badge
        if: (github.event_name == 'push') && (github.ref == 'refs/heads/main' || github.ref == 'refs/heads/master')
        uses: ad-m/github-push-action@master
        with:
          github_token: ${{ github.token }}
          branch: ${{github.ref}}

      - id: output-sha
        run: |
          if [ "push" = 'push' ] && [ \( "${{ github.ref }}" = 'refs/heads/main' \) -o \( "${{ github.ref }}" = 'refs/heads/master' \) ]; then
            sha=$(git rev-parse HEAD)
          else
            sha="${{ github.sha }}"
          fi
          echo "$sha"
          echo "sha=$sha" >> "$GITHUB_OUTPUT"

      - name: Coverage Quality Gate
        run: |
          echo "Quality Gate: checking test coverage is above threshold ..."
          echo "Threshold             : ${{ inputs.TESTCOVERAGE_THRESHOLD }}%"
          totalCoverage=`go tool cover -func=temp/coverage.out | grep 'total:' | grep -Eo '[0-9]+\.[0-9]+'`
          echo "Current test coverage : $totalCoverage %"
          totalInt=${totalCoverage%.*}
          if [ "$totalInt" -ge "${{ inputs.TESTCOVERAGE_THRESHOLD }}" ]; then
              echo "OK"
          else
              echo "Current test coverage is below threshold. Please add more unit tests or adjust threshold to a lower value."
              echo "Failed"
              exit 1
          fi

      - name: Run Server
        if: ${{ inputs.POSTMAN_ENABLED }}
        run: |
          GOFR_ENV=test go run main.go &
          sleep 30

      - name: Install newman and Run Postman Collection
        if: ${{ inputs.POSTMAN_ENABLED }}
        run: |
          npm install -g newman
          newman run postman-collections/${{ inputs.APP_NAME }}.postman-collection.json

      - name: Stop Server
        if: ${{ inputs.POSTMAN_ENABLED }}
        run: pkill main

      - name: Get dependencies
        if: (github.ref == 'refs/heads/main' || github.ref == 'refs/heads/master' || github.ref == 'refs/heads/development') && (github.event_name == 'push')
        run: |
          git config --global url."https://${{ secrets.PAT }}:x-oauth-basic@github.com/".insteadOf "https://github.com/"
          git config --global http.sslVerify false
          go mod download

      - name: Extra dependencies
        if: ${{ inputs.EXTRA_DEPENDENCIES }}
        run: |
          ${{ inputs.DEPENDENCIES_COMMAND }}

      - name: Make Directory
        if: (github.ref == 'refs/heads/main' || github.ref == 'refs/heads/master' || github.ref == 'refs/heads/development') && (github.event_name == 'push')
        run: mkdir build

      - name: Build
        if: (github.ref == 'refs/heads/main' || github.ref == 'refs/heads/master' || github.ref == 'refs/heads/development') && (github.event_name == 'push')
        run: |
          cd ${{ inputs.DOCKER_FILE_PATH }}
          ls
          pwd
          ${{ inputs.BUILD_COMMAND }}

      - name: Upload Artifacts
        if: (github.ref == 'refs/heads/main' || github.ref == 'refs/heads/master' || github.ref == 'refs/heads/development') && (github.event_name == 'push')
        uses: actions/upload-artifact@v2
        with:
          name: ${{ inputs.APP_NAME }}
          path: ${{ inputs.DOCKER_FILE_PATH }}/${{ inputs.ARTIFACT_PATH }}

      - name: Download Artifacts
        if: (github.ref == 'refs/heads/main' || github.ref == 'refs/heads/master' || github.ref == 'refs/heads/development') && (github.event_name == 'push')
        uses: actions/download-artifact@v2
        with:
          name: ${{ inputs.APP_NAME }}

      - name: Login to GAR
        if: (github.ref == 'refs/heads/main' || github.ref == 'refs/heads/master' || github.ref == 'refs/heads/development') && (github.event_name == 'push')
        uses: docker/login-action@v2
        with:
          registry: ${{ inputs.IMAGE_REGISTRY }}
          username: _json_key
          password: ${{ secrets.GAR_KEY }}

      - name: Build and Push Docker Image to gar
        if: (github.ref == 'refs/heads/main' || github.ref == 'refs/heads/master' || github.ref == 'refs/heads/development') && (github.event_name == 'push')
        uses: docker/build-push-action@v2
        with:
          push: true
          context: .
          file: ${{ inputs.DOCKER_FILE_PATH }}/Dockerfile
          tags: ${{ inputs.IMAGE_REGISTRY }}/${{ inputs.GAR_PROJECT }}/${{ inputs.GAR_REGISTRY }}/${{ inputs.APP_NAME }}:${{ steps.output-sha.outputs.sha }}
          build-args: |
            ${{ inputs.BUILD_ARGUMENTS }}
      - id: output-image
        run: echo "image=`echo  ${{ inputs.IMAGE_REGISTRY }}/${{ inputs.GAR_PROJECT }}/${{ inputs.GAR_REGISTRY }}/${{ inputs.APP_NAME }}:${{ steps.output-sha.outputs.sha }}`" >> "$GITHUB_OUTPUT"


      - id: check_files
        run: |
          if [[ $(git diff --name-only ${{ github.event.before }}..${{ github.sha }} | grep -E '\.(prod|stage)\.env') ]]; then
            echo "modified_files=true" >> "$GITHUB_OUTPUT"
          else
            echo "modified_files=false" >> "$GITHUB_OUTPUT"
          fi

      - name: Authorize to GCP service account
        if: ${{ steps.check_files.outputs.modified_files == 'true'}}
        uses: google-github-actions/auth@v1
        with:
          credentials_json: ${{ secrets.DEPLOY_KEY }}

      - name: Set GCloud Project and Fetch Cluster Credentials
        if: ${{ steps.check_files.outputs.modified_files == 'true'}}
        run: gcloud container clusters get-credentials ${{ inputs.CLUSTER_NAME }} --region=us-central1 --project=${{ inputs.CLUSTER_PROJECT }}

      - name: Read ENV Files
        if: ${{ steps.check_files.outputs.modified_files == 'true'}}
        id: read-env
        run: |
          CONFIG_MAP_NAME=${{ inputs.APP_NAME }}
          ENV_FILE_PATH=${{ inputs.ENV_FILE_PATH }}

          # Create an associative array to store key-value pairs
          declare -A envArray

          # Read each line in .env and extract key-value pairs
          while IFS= read -r line || [[ -n "$line" ]]; do
            if [ -z "$line" ] || [ "${line:0:1}" == "#" ]; then
              continue
            fi
            key=$(echo "$line" | cut -d '=' -f 1)
            value=$(echo "$line" | cut -d '=' -f 2-)
            envArray["$key"]=$value
          done < "$ENV_FILE_PATH"

          # Handle the case when the last line doesn't end with a newline character
          if [[ -n "$line" ]]; then
            key=$(echo "$line" | cut -d '=' -f 1)
            value=$(echo "$line" | cut -d '=' -f 2-)
            envArray["$key"]=$value
          fi

          # Read the .env file and create a ConfigMap YAML dynamically
          echo "apiVersion: v1" > $CONFIG_MAP_NAME.yaml
          echo "kind: ConfigMap" >> $CONFIG_MAP_NAME.yaml
          echo "metadata:" >> $CONFIG_MAP_NAME.yaml
          echo "  name: $CONFIG_MAP_NAME" >> $CONFIG_MAP_NAME.yaml
          echo "data:" >> $CONFIG_MAP_NAME.yaml
          for key in "${!envArray[@]}"; do
            echo "  $key: ${envArray[$key]}" >> $CONFIG_MAP_NAME.yaml
          done
        shell: bash

      - name: Update configmap
        if: ${{ steps.check_files.outputs.modified_files == 'true'}}
        run: kubectl apply --force -f ${{ inputs.APP_NAME }}.yaml -n ${{ inputs.NAMESPACE }}
